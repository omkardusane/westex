package core2

import (
	"fmt"
	"math/rand"
	"time"
	"westex/engines/economy/pkg/entities"
	"westex/engines/economy/pkg/logging"
)

type SimulationConfig struct {
	Ticks                    int
	WagePerHour              float32
	ConsumptionFactorPerWeek float32
}

var SimConf = SimulationConfig{
	Ticks:                    5,
	WagePerHour:              10.0,
	ConsumptionFactorPerWeek: 1.0,
}

// Engine is the core simulation engine
type Engine struct {
	Region         *entities.Region
	Logger         *logging.Logger
	CurrentTick    int
	WagePerHour    float32 // Standard wage rate
	PricePerUnit   float32 // Standard price per unit of product
	ProductionRate float32 // How much each industry produces per tick
	InitialState   *InitialState
}

type TickData struct {
	TickNumber       int
	WeeksCount       int
	ProducedGoods    []ProducedGoods
	LaborEmployments []LaborEmployment
}

// InitialState captures the starting state of the economy
type InitialState struct {
	IndustryMoney map[string]float32
	PersonMoney   map[string]float32
	TotalWealth   float32
}

func CreateNewEngine(region *entities.Region) *Engine {
	thisEngine := &Engine{
		Region:      region,
		Logger:      logging.NewLogger(true),
		CurrentTick: 0,
	}

	return thisEngine
}

// NewEngine creates a new simulation engine
func NewEngine(region *entities.Region, wagePerHour, pricePerUnit, productionRate float32) *Engine {
	// Capture initial state
	initialState := &InitialState{
		IndustryMoney: make(map[string]float32),
		PersonMoney:   make(map[string]float32),
		TotalWealth:   0,
	}

	// for _, ind := range region.Industries {
	// 	initialState.IndustryMoney[ind.Name] = ind.Money
	// 	initialState.TotalWealth += ind.Money
	// }
	for _, p := range region.People {
		initialState.PersonMoney[p.Name] = p.Money
		initialState.TotalWealth += p.Money
	}

	return &Engine{
		Region:         region,
		Logger:         logging.NewLogger(true),
		CurrentTick:    0,
		WagePerHour:    wagePerHour,
		PricePerUnit:   pricePerUnit,
		ProductionRate: productionRate,
		InitialState:   initialState,
	}
}

// Run executes the simulation for a given number of ticks
func (e *Engine) Run(ticks int) {
	fmt.Printf("\nðŸš€ Starting Economy Simulation for %d ticks...\n", ticks)
	fmt.Printf("Region: %s\n", e.Region.Name)
	fmt.Printf("Industries: %d, People: %d, Problems: %d\n",
		len(e.Region.Industries), len(e.Region.People), len(e.Region.Problems))

	for i := 0; i < ticks; i++ {
		e.CurrentTick = i + 1
		e.processTick()
		time.Sleep(200 * time.Millisecond) // Slow down for readability
	}

	e.printFinalSummary()
}

// processTick handles one simulation tick
func (e *Engine) processTick() {
	e.Logger.LogTick(e.CurrentTick)
	weeks := 4                   // Assuming each tick represents 4 weeks
	hours := float32(weeks * 40) // Assuming 40-hour work weeks
	TickContext := TickData{
		TickNumber: e.CurrentTick,
		WeeksCount: weeks,
	}

	// Phase 1: Industries produce goods
	e.Logger.LogEvent("ðŸ“¦ PRODUCTION PHASE")
	TickContext.ProducedGoods = e.processProduction(hours)
	// e.Logger.LogEvents(productionLogs)

	// Phase 2: Labor market - people work for industries
	// e.Logger.LogEvent("\nðŸ’¼ LABOR MARKET PHASE")
	// laborLogs := market.ProcessLaborMarket(e.Region, e.WagePerHour)
	// e.Logger.LogEvents(laborLogs)

	// // Phase 3: Product market - people buy products
	// e.Logger.LogEvent("\nðŸ›’ PRODUCT MARKET PHASE")
	// tradeLogs := market.ProcessProductMarket(e.Region, e.PricePerUnit)
	// e.Logger.LogEvents(tradeLogs)

	// // Phase 4: Reset labor hours for next tick
	// e.resetLaborHours()
}

type ProducedGoods struct {
	IndustryName     string
	ProductName      string
	Quantity         float32
	ProductionRate   float32
	ProductionTarget float32
}

type LaborEmployment struct {
	Quantity     float32
	IndustryName string
}

// processProduction simulates industries producing goods
func (e *Engine) processProduction(hours float32) []ProducedGoods {
	logIt := func(logLine string) {
		e.Logger.LogEvent(logLine)
	}
	pGoodsList := []ProducedGoods{}
	for _, industry := range e.Region.Industries {
		pGoods := &ProducedGoods{
			IndustryName: industry.Name,
		}
		LaborUtilized := LaborEmployment{
			IndustryName: industry.Name,
		}
		var LaborEmployed float32 = float32(0.3*rand.Float32()) * float32(len(e.Region.People)) // 30% of population employed
		LaborUtilized.Quantity = LaborEmployed
		var productionTargets map[string]float32 = make(map[string]float32) // consumer need
		//var totalProductionNeed float32
		//hours / industry.LaborNeeded
		for _, problem := range industry.OwnedProblems {
			peopleNeedingProduct := float32(len(e.Region.People)) * float32(problem.Demand)
			productionTargets[problem.Name] = peopleNeedingProduct // estimated need
			//totalProductionNeed += peopleNeedingProduct
			pGoods.ProductionTarget = peopleNeedingProduct
		}
		for _, product := range industry.OutputProducts {
			pGoods.ProductName = product.Name
			// product.Add(e.ProductionRate)
			// productionPerPerson := float32(1.0) //unit per person
			// productionTarget := float32(pGoods.productionTarget) * productionPerPerson
			pGoods.ProductionRate = float32(LaborUtilized.Quantity / industry.LaborNeeded)
			pGoods.Quantity = float32(pGoods.ProductionRate * hours) // units per tick
			// produced := productionPossiblePerTick
			logIt(fmt.Sprintf("âœ“ %s produced %.2f units of %s",
				industry.Name, pGoods.Quantity, product.Name))
		}
		pGoodsList = append(pGoodsList, *pGoods)
	}
	return pGoodsList
}

// resetLaborHours resets everyone's labor hours for the next tick
func (e *Engine) resetLaborHours() {
	for _, person := range e.Region.People {
		person.LaborHours = 8.0 // Standard 8-hour workday
	}
}

// printFinalSummary prints statistics at the end of simulation
func (e *Engine) printFinalSummary() {
	fmt.Printf("\n\n" + "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n")
	fmt.Printf("ðŸ“Š FINAL SIMULATION SUMMARY\n")
	fmt.Printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n")

	// Industry summary
	fmt.Printf("ðŸ­ INDUSTRIES:\n")
	for _, industry := range e.Region.Industries {
		start := e.InitialState.IndustryMoney[industry.Name]
		change := 0 //industry.Money - start
		fmt.Printf("  %s:\n", industry.Name)
		fmt.Printf("    Money: $%.2f (Start: $%.2f, Change: %+.2f)\n", industry.Money, start, change)
		fmt.Printf("    Products:\n")
		for _, product := range industry.OutputProducts {
			fmt.Printf("      - %s: %.2f %s\n", product.Name, product.Quantity, product.Unit)
		}
	}

	// People summary
	fmt.Printf("\nðŸ‘¥ PEOPLE (showing first 5):\n")
	for i, person := range e.Region.People {
		if i >= 5 {
			fmt.Printf("  ... and %d more\n", len(e.Region.People)-5)
			break
		}
		start := e.InitialState.PersonMoney[person.Name]
		change := person.Money - start
		fmt.Printf("  %s: $%.2f (Start: $%.2f, Change: %+.2f)\n", person.Name, person.Money, start, change)
	}

	// Calculate total wealth
	totalWealth := float32(0.0)
	for _, person := range e.Region.People {
		totalWealth += person.Money
	}
	// for _, industry := range e.Region.Industries {
	// 	 totalWealth += industry.Money
	// }

	wealthChange := totalWealth - e.InitialState.TotalWealth

	fmt.Printf("\nðŸ’° TOTAL WEALTH: $%.2f (Start: $%.2f, Change: %+.2f)\n", totalWealth, e.InitialState.TotalWealth, wealthChange)
	fmt.Printf("\nâœ… Simulation completed successfully!\n\n")
}
